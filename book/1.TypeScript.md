### TypeScript
#### 为什么要使用TypeScript
- 程序更容易理解
- 效率更高
- 更少的错误
- 非常好的包容性

#### 安装和初始TypeScript
安装TypeScript编译器
``` shell
npm install -g typescript
tsc -v
```
初始TypeScript: hello.ts
``` javascript
const hello = (name: string) => {
  return `hello ${name}`
}

const text = hello('kcs')
console.log(text)
```
编译
``` shell
tsc hello.ts
```

#### 基础类型
- 7种原始类型
  - Boolean
  - Null
  - Undefined
  - Number
  - BigInt
  - String
  - Symbol
- 和Object

basic-types.ts
``` javascript
let isDone: boolean = false

let age: number = 20
let binaryNumber: number = 0b1111

let firstName: string = 'viking'
let message: string = `Hello, ${firstName}, age is ${age}`

let u: undefined = undefined
let n: null = null

let num: number = undefined

```

#### any类型和联合类型
any类型
``` javascript
let notSure: any = 4
notSure = 'maybe it is a string'
notSure = true

notSure.myName
notSure.getName()
```
联合类型
``` javascript
let numberOrString: number | string = 234
numberOrString = 'abc'
```

#### Array和Tuple
Array
``` javascript
let arrOfNumbers: number[] = [1, 2, 3, 4]
arrOfNumbers.push(5)
```
Tuple
``` javascript
let user: [string, number] = ['kcs', 20]
```

#### Interface接口
- 对对象的形状(shape)进行描述
- 对类(class)进行抽象
- Duck Typing(鸭子类型)

interface.ts
``` javascript
interface Person {
  name: string;
  age: number;
}
let Kcshan: Person = {
  name: 'kcs',
  age: 20
}

// ?可有可无
interface Person2 {
  name: string;
  age?: number;
}
let Kcshan2: Person2 = {
  name: 'kcs',
}

// readonly只读属性
interface Person3 {
  readonly id: number;
  name: string;
  age?: number;
}
let Kcshan3: Person3 = {
  id: 123,
  name: 'kcs',
}
```

#### 函数和类型推断
functions.ts
``` javascript
const add = function(x: number, y: number, z: number = 10): number {
  if (typeof z === 'number') {
    return x + y + z
  } else {
    return x + y
  }
}

let result = add(2, 3)
console.log(result)

const add2: (x: number, y: number, z?: number) => number = add
let result2 = add2(2, 3)
console.log(result2)
```

#### 类(Class) 第一部分
- 类(Class): 定义了一切事物的抽象特点
- 对象(Object): 类的实例
- 面向对象(OOP): 三大特性: 封装、继承、多态

class.ts
``` javascript
class Animal {
  name: string;
  constructor(name: string) {
    this.name = name
  }
  run() {
    return `${this.name} is running`
  }
}
const snake = new Animal('lily')
console.log(snake.run())

class Dog extends Animal {
  bark() {
    return `${this.name} is barking`
  }
}
const xb = new Dog('xiaobao')
console.log(xb.run())
console.log(xb.bark())

class Cat extends Animal {
  constructor(name) {
    super(name)
    console.log(this.name)
  }
  run() {
    return 'Meow, ' + super.run()
  }
}
const maomao = new Cat('maomao')
console.log(maomao.run());
```

``` shell
npm install -g ts-node
ts-node claass.ts
```

#### 类(Class) 第二部分
修饰符:
- public 公共的
- private 私有的
- readonly 只读的
- static 静态的

class.ts
``` javascript
class Animal {
  name: string;
  static categoies: string[] = ['mammal', 'bird']
  static isAnimal(a) {
    return a instanceof Animal
  }
  constructor(name: string) {
    this.name = name
  }
  run() {
    return `${this.name} is running`
  }
}
console.log(Animal.categoies)
const snake = new Animal('lily')
console.log(Animal.isAnimal(snake))
console.log(snake.name)
snake.name = 'lucy'
console.log(snake.name)
```

#### 类和接口
class.ts
``` javascript
interface Radio {
  switchRadio(): void;
}
interface Battery {
  checkBatteryStatus();
}
interface RadioWithBattery extends Radio {
  checkBatteryStatus();
}
class Car implements Radio {
  switchRadio() {

  }
}
class CellPhone implements RadioWithBattery {
  switchRadio() {

  }
  checkBatteryStatus() {

  }
}
```

#### 枚举(Enum)
enums.ts
``` javascript
const enum Direction {
  Up = 'UP',
  Down = 'DOWN',
  Left = 'LEFT',
  Right = 'RIGHT',
}
const value = 'UP'
if (value === Direction.Up) {
  console.log('go up!')
}
```

#### 泛型(Generics) 第一部分
generics.ts
``` javascript
function echo<T>(arg: T): T {
  return arg
}
const result = echo('str')

function swap<T, U>(tuple: [T, U]): [U, T] {
  return [tuple[1], tuple[0]]
}
const result2 = swap(['string', 123])

```

#### 泛型(Generics) 第二部分 约束泛型
generics.ts
``` javascript
interface IWitchLength {
  length: number
}
function echoWithLength<T extends IWitchLength>(arg: T): T {
  console.log(arg.length)
  return arg
}
const str = echoWithLength('str')
const obj = echoWithLength({ length: 10 })
const arr = echoWithLength([12, 3, 4])
```

#### 泛型(Generics) 第三部分 类和接口
generics.ts 
``` javascript
class Queue<T> {
  private data = []
  push(item: T) {
    return this.data.push(item)
  }
  pop(): T {
    return this.data.shift()
  }
}
const queue = new Queue<number>()
queue.push(1)
console.log(queue.pop().toFixed())
const queue2 = new Queue<string>()
queue2.push('str')
console.log(queue2.pop().length)

interface KeyPair<T, U> {
  key: T;
  value: U;
}
let kp1: KeyPair<number, string> = { key: 123, value: 'str' }
let kp2: KeyPair<string, number> = { key: 'str', value: 123 }

let arr2: number[] = [12, 3, 4]
let arr3: Array<number> = [1, 3, 4]

interface IPlus<T> {
  (a: T, b: T): T
}
function plus(a: number, b: number): number {
  return a + b
} 

function connect(a: string, b: string): string {
  return a + b
}
const a: IPlus<number> = plus
const b: IPlus<string> = connect
```

#### 类型别名和类型断言


#### 声明文件